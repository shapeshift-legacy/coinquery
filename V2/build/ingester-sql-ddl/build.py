#!/usr/bin/env python
"""Process/Generate templates, `template/coins/*` -> `gen/*`.

Directories within `./template/coins/` should contain a config.json in the form:

    {
        "rootTemplate": "<path-to-root-template>",
        "parameters": {
            "schema": "<coin-symbol>"
        }
    }

- Where `rootTemplate` names a directory in `./template/common/`.
- Any files placed within the coin directory will overwrite common files.
- If the files contain template markup `<%=name%>`, the "parameters"
  section of config.json will be searched for "name" and inserted.

Running this build process will generate all coins into `./gen/`.
"""

# BEGIN PYTHON 2/3 COMPAT
from __future__ import (
    absolute_import, division, print_function, unicode_literals)

from builtins import (
    bytes, dict, int, list, object, range, str,
    ascii, chr, hex, input, next, oct, open,
    pow, round, super,
    filter, map, zip)

from future.utils import raise_with_traceback
# END PYTHON 2/3 COMPAT

import traceback

from io import open
import os
import stat
import json

# -- configure "constants" -- #

COINS_DIR = os.path.join('.', 'template', 'coins')
ROOT_TEMPLATE_DIR = os.path.join('.', 'template', 'common')
GEN_DIR = os.path.join('.', 'gen')
READ_BUF_SIZE = 4096

SQL_HEADER = '''
-- FILE AUTO GENERATED BY build.py TEMPLATE SYSTEM
-- DO NOT EDIT

'''

CONF_HEADER = '''
# FILE AUTO GENERATED BY build.py TEMPLATE SYSTEM
# DO NOT EDIT

'''

HEADER_MAP = {
    '.sql': SQL_HEADER,
    '.conf': CONF_HEADER,
    '.sh': CONF_HEADER,
    '.plan': ''
}

# -- functions -- #

def ensureDir(path):
    """Split the input `path` and make sure all directories exist along it."""
    parts = []
    tmp = os.path.split(path)
    while len(tmp[0]) > 0:
        parts.insert(0, tmp[1])
        tmp = os.path.split(tmp[0])
    cur = tmp[1]
    for part in parts:
        cur = os.path.join(cur, part)
        try:
            if stat.S_ISDIR(os.stat(cur).st_mode):
                continue
        except Exception as e:
            pass
        os.mkdir(cur)

def _recListFiles(curdir, path, obj):
    """Recursive helper, see `listFiles`."""
    for f in os.listdir(curdir):
        npath = f
        if len(path) > 0:
            npath = os.path.join(path, f)
        full = os.path.join(curdir, f)
        s = os.stat(full)
        if stat.S_ISDIR(s.st_mode):
            _recListFiles(full, npath, obj)
        elif stat.S_ISREG(s.st_mode):
            obj[npath] = full

def listFiles(dir):
    """List all files recursively under `dir`."""
    out = {}
    _recListFiles(dir, "", out)
    return out

def fetchCoinConfigs():
    """Fetch the template configurations for individual coins."""
    coins = []
    for f in os.listdir(COINS_DIR):
        coinDir = os.path.join(COINS_DIR, f)
        s = os.stat(coinDir)
        if not stat.S_ISDIR(s.st_mode):
            continue
        configF = open(os.path.join(coinDir, 'config.json'), encoding='utf-8')
        config = configF.read()
        configF.close()

        config = json.loads(config)
        config['_coin'] = f
        config['_coinDir'] = coinDir
        config['_rootTemplateDir'] = os.path.join(
            ROOT_TEMPLATE_DIR, config['rootTemplate'])

        templateFiles = listFiles(config['_rootTemplateDir'])
        overrideFiles = listFiles(config['_coinDir'])
        for key in overrideFiles:
            templateFiles[key] = overrideFiles[key]
        config['_files'] = templateFiles
        coins.append(config)
    return coins

def generateFromTemplate(dest, src, parameters, header):
    """Copy src, applying template paramaters, to dest.

    `<%=name%>` will insert `parameters[name]`
    """

    tag = 'override'
    if src.find(ROOT_TEMPLATE_DIR) > -1:
        tag = 'common'
    print(' - TEMPLATE', tag, dest)

    srcF = open(src, encoding='utf-8')
    destF = open(dest, 'wt', encoding='utf-8')

    buf = [header]
    tmp = []
    state = 0

    data = srcF.read(READ_BUF_SIZE)
    while len(data) > 0:
        for c in data:
            if state == 0 and c == '<':
                state = 1
                tmp = []
            elif state == 1:
                if c == '%':
                    state = 2
                else:
                    buf.append('<')
                    buf.append(c)
                    state = 0
            elif state == 2:
                if c == '=':
                    state = 3
                else:
                    buf.append('<%')
                    buf.append(c)
                    state = 0
            elif state == 3:
                if c == '%':
                    state = 4
                else:
                    tmp.append(c)
            elif state == 4:
                if c != '>':
                    raise_with_traceback(RuntimeError('bad template'))
                else:
                    key = ''.join(tmp)
                    if not key in parameters:
                        raise_with_traceback(
                            RuntimeError('bad template parameter: ' + key))
                    buf.append(parameters[key])
                    state = 0
            else:
                buf.append(c)
        if len(buf) > 0:
            destF.write(''.join(buf))
            buf = []
        data = srcF.read(READ_BUF_SIZE)

    srcF.close()
    destF.close()

def processTemplate(config):
    """Process the specific coin template supplied by `config`."""
    print('BUILD', config['_coin'])
    destDir = os.path.join(GEN_DIR, config['_coin'])
    files = list(config['_files'])
    files.sort()
    for key in files:
        dest = os.path.join(destDir, key)
        src = config['_files'][key]
        ext = os.path.splitext(dest)[1]
        if not ext in HEADER_MAP:
            continue
        ensureDir(os.path.dirname(dest))
        generateFromTemplate(dest, src, config['parameters'], HEADER_MAP[ext])

def main():
    """Main entrypoint function for sql template build system."""
    for config in fetchCoinConfigs():
        processTemplate(config)

# -- entrypoint -- #

if __name__ == '__main__':
    try:
        main()
    except Exception as e:
        traceback.print_exc()
