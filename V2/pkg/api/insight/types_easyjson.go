// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package insight

import (
	json "encoding/json"
	utxo "github.com/shapeshift-legacy/coinquery/V2/pkg/blockchain/utxo"
	easyjson "github.com/mailru/easyjson"
	jlexer "github.com/mailru/easyjson/jlexer"
	jwriter "github.com/mailru/easyjson/jwriter"
)

// suppress unused package warning
var (
	_ *json.RawMessage
	_ *jlexer.Lexer
	_ *jwriter.Writer
	_ easyjson.Marshaler
)

func easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight(in *jlexer.Lexer, out *insightVout) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "value":
			out.Value = string(in.String())
		case "n":
			out.N = int(in.Int())
		case "scriptPubKey":
			easyjson6601e8cdDecode(in, &out.ScriptPubKey)
		case "spentTxId":
			if in.IsNull() {
				in.Skip()
				out.SpentTxID = nil
			} else {
				if out.SpentTxID == nil {
					out.SpentTxID = new(string)
				}
				*out.SpentTxID = string(in.String())
			}
		case "spentIndex":
			if in.IsNull() {
				in.Skip()
				out.SpentTxIndex = nil
			} else {
				if out.SpentTxIndex == nil {
					out.SpentTxIndex = new(int)
				}
				*out.SpentTxIndex = int(in.Int())
			}
		case "spentHeight":
			if in.IsNull() {
				in.Skip()
				out.SpentTxBlockHeight = nil
			} else {
				if out.SpentTxBlockHeight == nil {
					out.SpentTxBlockHeight = new(int64)
				}
				*out.SpentTxBlockHeight = int64(in.Int64())
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight(out *jwriter.Writer, in insightVout) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"value\":"
		out.RawString(prefix[1:])
		out.String(string(in.Value))
	}
	{
		const prefix string = ",\"n\":"
		out.RawString(prefix)
		out.Int(int(in.N))
	}
	{
		const prefix string = ",\"scriptPubKey\":"
		out.RawString(prefix)
		easyjson6601e8cdEncode(out, in.ScriptPubKey)
	}
	{
		const prefix string = ",\"spentTxId\":"
		out.RawString(prefix)
		if in.SpentTxID == nil {
			out.RawString("null")
		} else {
			out.String(string(*in.SpentTxID))
		}
	}
	{
		const prefix string = ",\"spentIndex\":"
		out.RawString(prefix)
		if in.SpentTxIndex == nil {
			out.RawString("null")
		} else {
			out.Int(int(*in.SpentTxIndex))
		}
	}
	{
		const prefix string = ",\"spentHeight\":"
		out.RawString(prefix)
		if in.SpentTxBlockHeight == nil {
			out.RawString("null")
		} else {
			out.Int64(int64(*in.SpentTxBlockHeight))
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v insightVout) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v insightVout) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *insightVout) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *insightVout) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight(l, v)
}
func easyjson6601e8cdDecode(in *jlexer.Lexer, out *struct {
	Asm       string   `json:"asm"`
	Hex       string   `json:"hex"`
	ReqSigs   int      `json:"reqSigs,omitempty"`
	Addresses []string `json:"addresses,omitempty"`
	Type      string   `json:"type,omitempty"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "asm":
			out.Asm = string(in.String())
		case "hex":
			out.Hex = string(in.String())
		case "reqSigs":
			out.ReqSigs = int(in.Int())
		case "addresses":
			if in.IsNull() {
				in.Skip()
				out.Addresses = nil
			} else {
				in.Delim('[')
				if out.Addresses == nil {
					if !in.IsDelim(']') {
						out.Addresses = make([]string, 0, 4)
					} else {
						out.Addresses = []string{}
					}
				} else {
					out.Addresses = (out.Addresses)[:0]
				}
				for !in.IsDelim(']') {
					var v1 string
					v1 = string(in.String())
					out.Addresses = append(out.Addresses, v1)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "type":
			out.Type = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson6601e8cdEncode(out *jwriter.Writer, in struct {
	Asm       string   `json:"asm"`
	Hex       string   `json:"hex"`
	ReqSigs   int      `json:"reqSigs,omitempty"`
	Addresses []string `json:"addresses,omitempty"`
	Type      string   `json:"type,omitempty"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"asm\":"
		out.RawString(prefix[1:])
		out.String(string(in.Asm))
	}
	{
		const prefix string = ",\"hex\":"
		out.RawString(prefix)
		out.String(string(in.Hex))
	}
	if in.ReqSigs != 0 {
		const prefix string = ",\"reqSigs\":"
		out.RawString(prefix)
		out.Int(int(in.ReqSigs))
	}
	if len(in.Addresses) != 0 {
		const prefix string = ",\"addresses\":"
		out.RawString(prefix)
		{
			out.RawByte('[')
			for v2, v3 := range in.Addresses {
				if v2 > 0 {
					out.RawByte(',')
				}
				out.String(string(v3))
			}
			out.RawByte(']')
		}
	}
	if in.Type != "" {
		const prefix string = ",\"type\":"
		out.RawString(prefix)
		out.String(string(in.Type))
	}
	out.RawByte('}')
}
func easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight1(in *jlexer.Lexer, out *insightVin) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "txid":
			out.TxID = string(in.String())
		case "vout":
			if in.IsNull() {
				in.Skip()
				out.Vout = nil
			} else {
				if out.Vout == nil {
					out.Vout = new(int)
				}
				*out.Vout = int(in.Int())
			}
		case "n":
			out.N = int(in.Int())
		case "scriptSig":
			if in.IsNull() {
				in.Skip()
				out.ScriptSig = nil
			} else {
				if out.ScriptSig == nil {
					out.ScriptSig = new(ScriptSig)
				}
				(*out.ScriptSig).UnmarshalEasyJSON(in)
			}
		case "txinwitness":
			if in.IsNull() {
				in.Skip()
				out.TxInWitness = nil
			} else {
				in.Delim('[')
				if out.TxInWitness == nil {
					if !in.IsDelim(']') {
						out.TxInWitness = make([]string, 0, 4)
					} else {
						out.TxInWitness = []string{}
					}
				} else {
					out.TxInWitness = (out.TxInWitness)[:0]
				}
				for !in.IsDelim(']') {
					var v4 string
					v4 = string(in.String())
					out.TxInWitness = append(out.TxInWitness, v4)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "sequence":
			out.Sequence = int(in.Int())
		case "coinbase":
			out.Coinbase = string(in.String())
		case "addr":
			out.Address = string(in.String())
		case "valueSat":
			out.ValueSat = int64(in.Int64())
		case "value":
			out.Value = float64(in.Float64())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight1(out *jwriter.Writer, in insightVin) {
	out.RawByte('{')
	first := true
	_ = first
	if in.TxID != "" {
		const prefix string = ",\"txid\":"
		first = false
		out.RawString(prefix[1:])
		out.String(string(in.TxID))
	}
	if in.Vout != nil {
		const prefix string = ",\"vout\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int(int(*in.Vout))
	}
	{
		const prefix string = ",\"n\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int(int(in.N))
	}
	{
		const prefix string = ",\"scriptSig\":"
		out.RawString(prefix)
		if in.ScriptSig == nil {
			out.RawString("null")
		} else {
			(*in.ScriptSig).MarshalEasyJSON(out)
		}
	}
	if len(in.TxInWitness) != 0 {
		const prefix string = ",\"txinwitness\":"
		out.RawString(prefix)
		{
			out.RawByte('[')
			for v5, v6 := range in.TxInWitness {
				if v5 > 0 {
					out.RawByte(',')
				}
				out.String(string(v6))
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"sequence\":"
		out.RawString(prefix)
		out.Int(int(in.Sequence))
	}
	if in.Coinbase != "" {
		const prefix string = ",\"coinbase\":"
		out.RawString(prefix)
		out.String(string(in.Coinbase))
	}
	if in.Address != "" {
		const prefix string = ",\"addr\":"
		out.RawString(prefix)
		out.String(string(in.Address))
	}
	if in.ValueSat != 0 {
		const prefix string = ",\"valueSat\":"
		out.RawString(prefix)
		out.Int64(int64(in.ValueSat))
	}
	if in.Value != 0 {
		const prefix string = ",\"value\":"
		out.RawString(prefix)
		out.Float64(float64(in.Value))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v insightVin) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight1(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v insightVin) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight1(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *insightVin) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight1(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *insightVin) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight1(l, v)
}
func easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight2(in *jlexer.Lexer, out *insightUtxos) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		in.Skip()
		*out = nil
	} else {
		in.Delim('[')
		if *out == nil {
			if !in.IsDelim(']') {
				*out = make(insightUtxos, 0, 8)
			} else {
				*out = insightUtxos{}
			}
		} else {
			*out = (*out)[:0]
		}
		for !in.IsDelim(']') {
			var v7 *insightUtxo
			if in.IsNull() {
				in.Skip()
				v7 = nil
			} else {
				if v7 == nil {
					v7 = new(insightUtxo)
				}
				(*v7).UnmarshalEasyJSON(in)
			}
			*out = append(*out, v7)
			in.WantComma()
		}
		in.Delim(']')
	}
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight2(out *jwriter.Writer, in insightUtxos) {
	if in == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
		out.RawString("null")
	} else {
		out.RawByte('[')
		for v8, v9 := range in {
			if v8 > 0 {
				out.RawByte(',')
			}
			if v9 == nil {
				out.RawString("null")
			} else {
				(*v9).MarshalEasyJSON(out)
			}
		}
		out.RawByte(']')
	}
}

// MarshalJSON supports json.Marshaler interface
func (v insightUtxos) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight2(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v insightUtxos) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight2(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *insightUtxos) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight2(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *insightUtxos) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight2(l, v)
}
func easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight3(in *jlexer.Lexer, out *insightUtxo) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "address":
			out.Address = string(in.String())
		case "txid":
			out.TxID = string(in.String())
		case "vout":
			out.Vout = int(in.Int())
		case "scriptPubKey":
			out.ScriptPubKey = string(in.String())
		case "reqSigs":
			out.ReqSigs = int(in.Int())
		case "type":
			out.Type = string(in.String())
		case "amount":
			out.Amount = float64(in.Float64())
		case "satoshis":
			out.Satoshis = int64(in.Int64())
		case "blockheight":
			out.BlockHeight = int64(in.Int64())
		case "confirmations":
			out.Confirmations = int(in.Int())
		case "ts":
			out.Timestamp = int64(in.Int64())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight3(out *jwriter.Writer, in insightUtxo) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"address\":"
		out.RawString(prefix[1:])
		out.String(string(in.Address))
	}
	{
		const prefix string = ",\"txid\":"
		out.RawString(prefix)
		out.String(string(in.TxID))
	}
	{
		const prefix string = ",\"vout\":"
		out.RawString(prefix)
		out.Int(int(in.Vout))
	}
	{
		const prefix string = ",\"scriptPubKey\":"
		out.RawString(prefix)
		out.String(string(in.ScriptPubKey))
	}
	if in.ReqSigs != 0 {
		const prefix string = ",\"reqSigs\":"
		out.RawString(prefix)
		out.Int(int(in.ReqSigs))
	}
	if in.Type != "" {
		const prefix string = ",\"type\":"
		out.RawString(prefix)
		out.String(string(in.Type))
	}
	{
		const prefix string = ",\"amount\":"
		out.RawString(prefix)
		out.Float64(float64(in.Amount))
	}
	{
		const prefix string = ",\"satoshis\":"
		out.RawString(prefix)
		out.Int64(int64(in.Satoshis))
	}
	{
		const prefix string = ",\"blockheight\":"
		out.RawString(prefix)
		out.Int64(int64(in.BlockHeight))
	}
	{
		const prefix string = ",\"confirmations\":"
		out.RawString(prefix)
		out.Int(int(in.Confirmations))
	}
	{
		const prefix string = ",\"ts\":"
		out.RawString(prefix)
		out.Int64(int64(in.Timestamp))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v insightUtxo) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight3(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v insightUtxo) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight3(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *insightUtxo) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight3(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *insightUtxo) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight3(l, v)
}
func easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight4(in *jlexer.Lexer, out *insightTxsByBlock) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "pagesTotal":
			out.PagesTotal = int(in.Int())
		case "txs":
			if in.IsNull() {
				in.Skip()
				out.Txs = nil
			} else {
				in.Delim('[')
				if out.Txs == nil {
					if !in.IsDelim(']') {
						out.Txs = make([]*insightTx, 0, 8)
					} else {
						out.Txs = []*insightTx{}
					}
				} else {
					out.Txs = (out.Txs)[:0]
				}
				for !in.IsDelim(']') {
					var v10 *insightTx
					if in.IsNull() {
						in.Skip()
						v10 = nil
					} else {
						if v10 == nil {
							v10 = new(insightTx)
						}
						(*v10).UnmarshalEasyJSON(in)
					}
					out.Txs = append(out.Txs, v10)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight4(out *jwriter.Writer, in insightTxsByBlock) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"pagesTotal\":"
		out.RawString(prefix[1:])
		out.Int(int(in.PagesTotal))
	}
	{
		const prefix string = ",\"txs\":"
		out.RawString(prefix)
		if in.Txs == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v11, v12 := range in.Txs {
				if v11 > 0 {
					out.RawByte(',')
				}
				if v12 == nil {
					out.RawString("null")
				} else {
					(*v12).MarshalEasyJSON(out)
				}
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v insightTxsByBlock) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight4(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v insightTxsByBlock) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight4(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *insightTxsByBlock) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight4(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *insightTxsByBlock) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight4(l, v)
}
func easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight5(in *jlexer.Lexer, out *insightTxHistoryByAddrs) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "totalItems":
			out.TotalItems = int(in.Int())
		case "from":
			out.From = int(in.Int())
		case "to":
			out.To = int(in.Int())
		case "items":
			if in.IsNull() {
				in.Skip()
				out.Txs = nil
			} else {
				in.Delim('[')
				if out.Txs == nil {
					if !in.IsDelim(']') {
						out.Txs = make([]*insightTx, 0, 8)
					} else {
						out.Txs = []*insightTx{}
					}
				} else {
					out.Txs = (out.Txs)[:0]
				}
				for !in.IsDelim(']') {
					var v13 *insightTx
					if in.IsNull() {
						in.Skip()
						v13 = nil
					} else {
						if v13 == nil {
							v13 = new(insightTx)
						}
						(*v13).UnmarshalEasyJSON(in)
					}
					out.Txs = append(out.Txs, v13)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight5(out *jwriter.Writer, in insightTxHistoryByAddrs) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"totalItems\":"
		out.RawString(prefix[1:])
		out.Int(int(in.TotalItems))
	}
	{
		const prefix string = ",\"from\":"
		out.RawString(prefix)
		out.Int(int(in.From))
	}
	{
		const prefix string = ",\"to\":"
		out.RawString(prefix)
		out.Int(int(in.To))
	}
	{
		const prefix string = ",\"items\":"
		out.RawString(prefix)
		if in.Txs == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v14, v15 := range in.Txs {
				if v14 > 0 {
					out.RawByte(',')
				}
				if v15 == nil {
					out.RawString("null")
				} else {
					(*v15).MarshalEasyJSON(out)
				}
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v insightTxHistoryByAddrs) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight5(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v insightTxHistoryByAddrs) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight5(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *insightTxHistoryByAddrs) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight5(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *insightTxHistoryByAddrs) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight5(l, v)
}
func easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight6(in *jlexer.Lexer, out *insightTx) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "txid":
			out.TxID = string(in.String())
		case "hash":
			out.Hash = string(in.String())
		case "version":
			out.Version = int(in.Int())
		case "size":
			out.Size = int(in.Int())
		case "vsize":
			out.VSize = int(in.Int())
		case "weight":
			out.Weight = int(in.Int())
		case "locktime":
			out.Locktime = int(in.Int())
		case "vin":
			if in.IsNull() {
				in.Skip()
				out.Vin = nil
			} else {
				in.Delim('[')
				if out.Vin == nil {
					if !in.IsDelim(']') {
						out.Vin = make([]*insightVin, 0, 8)
					} else {
						out.Vin = []*insightVin{}
					}
				} else {
					out.Vin = (out.Vin)[:0]
				}
				for !in.IsDelim(']') {
					var v16 *insightVin
					if in.IsNull() {
						in.Skip()
						v16 = nil
					} else {
						if v16 == nil {
							v16 = new(insightVin)
						}
						(*v16).UnmarshalEasyJSON(in)
					}
					out.Vin = append(out.Vin, v16)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "vout":
			if in.IsNull() {
				in.Skip()
				out.Vout = nil
			} else {
				in.Delim('[')
				if out.Vout == nil {
					if !in.IsDelim(']') {
						out.Vout = make([]*insightVout, 0, 8)
					} else {
						out.Vout = []*insightVout{}
					}
				} else {
					out.Vout = (out.Vout)[:0]
				}
				for !in.IsDelim(']') {
					var v17 *insightVout
					if in.IsNull() {
						in.Skip()
						v17 = nil
					} else {
						if v17 == nil {
							v17 = new(insightVout)
						}
						(*v17).UnmarshalEasyJSON(in)
					}
					out.Vout = append(out.Vout, v17)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "blockhash":
			out.BlockHash = string(in.String())
		case "blockheight":
			out.BlockHeight = int64(in.Int64())
		case "confirmations":
			out.Confirmations = int(in.Int())
		case "time":
			out.Time = int64(in.Int64())
		case "blocktime":
			out.BlockTime = int64(in.Int64())
		case "isCoinBase":
			out.IsCoinBase = bool(in.Bool())
		case "valueOut":
			out.ValueOut = float64(in.Float64())
		case "valueIn":
			out.ValueIn = float64(in.Float64())
		case "fees":
			if in.IsNull() {
				in.Skip()
				out.Fees = nil
			} else {
				if out.Fees == nil {
					out.Fees = new(float64)
				}
				*out.Fees = float64(in.Float64())
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight6(out *jwriter.Writer, in insightTx) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"txid\":"
		out.RawString(prefix[1:])
		out.String(string(in.TxID))
	}
	{
		const prefix string = ",\"hash\":"
		out.RawString(prefix)
		out.String(string(in.Hash))
	}
	{
		const prefix string = ",\"version\":"
		out.RawString(prefix)
		out.Int(int(in.Version))
	}
	{
		const prefix string = ",\"size\":"
		out.RawString(prefix)
		out.Int(int(in.Size))
	}
	{
		const prefix string = ",\"vsize\":"
		out.RawString(prefix)
		out.Int(int(in.VSize))
	}
	{
		const prefix string = ",\"weight\":"
		out.RawString(prefix)
		out.Int(int(in.Weight))
	}
	{
		const prefix string = ",\"locktime\":"
		out.RawString(prefix)
		out.Int(int(in.Locktime))
	}
	{
		const prefix string = ",\"vin\":"
		out.RawString(prefix)
		if in.Vin == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v18, v19 := range in.Vin {
				if v18 > 0 {
					out.RawByte(',')
				}
				if v19 == nil {
					out.RawString("null")
				} else {
					(*v19).MarshalEasyJSON(out)
				}
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"vout\":"
		out.RawString(prefix)
		if in.Vout == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v20, v21 := range in.Vout {
				if v20 > 0 {
					out.RawByte(',')
				}
				if v21 == nil {
					out.RawString("null")
				} else {
					(*v21).MarshalEasyJSON(out)
				}
			}
			out.RawByte(']')
		}
	}
	if in.BlockHash != "" {
		const prefix string = ",\"blockhash\":"
		out.RawString(prefix)
		out.String(string(in.BlockHash))
	}
	{
		const prefix string = ",\"blockheight\":"
		out.RawString(prefix)
		out.Int64(int64(in.BlockHeight))
	}
	{
		const prefix string = ",\"confirmations\":"
		out.RawString(prefix)
		out.Int(int(in.Confirmations))
	}
	{
		const prefix string = ",\"time\":"
		out.RawString(prefix)
		out.Int64(int64(in.Time))
	}
	if in.BlockTime != 0 {
		const prefix string = ",\"blocktime\":"
		out.RawString(prefix)
		out.Int64(int64(in.BlockTime))
	}
	if in.IsCoinBase {
		const prefix string = ",\"isCoinBase\":"
		out.RawString(prefix)
		out.Bool(bool(in.IsCoinBase))
	}
	{
		const prefix string = ",\"valueOut\":"
		out.RawString(prefix)
		out.Float64(float64(in.ValueOut))
	}
	if in.ValueIn != 0 {
		const prefix string = ",\"valueIn\":"
		out.RawString(prefix)
		out.Float64(float64(in.ValueIn))
	}
	if in.Fees != nil {
		const prefix string = ",\"fees\":"
		out.RawString(prefix)
		out.Float64(float64(*in.Fees))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v insightTx) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight6(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v insightTx) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight6(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *insightTx) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight6(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *insightTx) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight6(l, v)
}
func easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight7(in *jlexer.Lexer, out *insightBlock) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	out.Block = new(utxo.Block)
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "confirmations":
			out.Confirmations = int(in.Int())
		case "tx":
			if in.IsNull() {
				in.Skip()
				out.Txs = nil
			} else {
				in.Delim('[')
				if out.Txs == nil {
					if !in.IsDelim(']') {
						out.Txs = make([]utxo.Tx, 0, 1)
					} else {
						out.Txs = []utxo.Tx{}
					}
				} else {
					out.Txs = (out.Txs)[:0]
				}
				for !in.IsDelim(']') {
					var v22 utxo.Tx
					easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgBlockchainUtxo(in, &v22)
					out.Txs = append(out.Txs, v22)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "hash":
			out.Hash = string(in.String())
		case "height":
			out.Height = int(in.Int())
		case "time":
			out.Time = int(in.Int())
		case "mediantime":
			out.MedianTime = int(in.Int())
		case "nonce":
			out.Nonce = int(in.Int())
		case "previousblockhash":
			out.PrevHash = string(in.String())
		case "nextblockhash":
			out.NextHash = string(in.String())
		case "bits":
			out.Bits = string(in.String())
		case "difficulty":
			out.Difficulty = in.JsonNumber()
		case "chainwork":
			out.Chainwork = string(in.String())
		case "version":
			out.Version = int(in.Int())
		case "versionHex":
			out.VersionHex = string(in.String())
		case "merkleroot":
			out.MerkleRoot = string(in.String())
		case "size":
			out.Size = int(in.Int())
		case "strippedsize":
			out.StrippedSize = int(in.Int())
		case "weight":
			out.Weight = int(in.Int())
		case "nTx":
			out.TxCount = int(in.Int())
		case "isOrphan":
			out.IsOrphan = bool(in.Bool())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight7(out *jwriter.Writer, in insightBlock) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"confirmations\":"
		out.RawString(prefix[1:])
		out.Int(int(in.Confirmations))
	}
	if len(in.Txs) != 0 {
		const prefix string = ",\"tx\":"
		out.RawString(prefix)
		{
			out.RawByte('[')
			for v23, v24 := range in.Txs {
				if v23 > 0 {
					out.RawByte(',')
				}
				easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgBlockchainUtxo(out, v24)
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"hash\":"
		out.RawString(prefix)
		out.String(string(in.Hash))
	}
	{
		const prefix string = ",\"height\":"
		out.RawString(prefix)
		out.Int(int(in.Height))
	}
	{
		const prefix string = ",\"time\":"
		out.RawString(prefix)
		out.Int(int(in.Time))
	}
	{
		const prefix string = ",\"mediantime\":"
		out.RawString(prefix)
		out.Int(int(in.MedianTime))
	}
	{
		const prefix string = ",\"nonce\":"
		out.RawString(prefix)
		out.Int(int(in.Nonce))
	}
	{
		const prefix string = ",\"previousblockhash\":"
		out.RawString(prefix)
		out.String(string(in.PrevHash))
	}
	{
		const prefix string = ",\"nextblockhash\":"
		out.RawString(prefix)
		out.String(string(in.NextHash))
	}
	{
		const prefix string = ",\"bits\":"
		out.RawString(prefix)
		out.String(string(in.Bits))
	}
	{
		const prefix string = ",\"difficulty\":"
		out.RawString(prefix)
		out.String(string(in.Difficulty))
	}
	{
		const prefix string = ",\"chainwork\":"
		out.RawString(prefix)
		out.String(string(in.Chainwork))
	}
	{
		const prefix string = ",\"version\":"
		out.RawString(prefix)
		out.Int(int(in.Version))
	}
	{
		const prefix string = ",\"versionHex\":"
		out.RawString(prefix)
		out.String(string(in.VersionHex))
	}
	{
		const prefix string = ",\"merkleroot\":"
		out.RawString(prefix)
		out.String(string(in.MerkleRoot))
	}
	{
		const prefix string = ",\"size\":"
		out.RawString(prefix)
		out.Int(int(in.Size))
	}
	{
		const prefix string = ",\"strippedsize\":"
		out.RawString(prefix)
		out.Int(int(in.StrippedSize))
	}
	{
		const prefix string = ",\"weight\":"
		out.RawString(prefix)
		out.Int(int(in.Weight))
	}
	{
		const prefix string = ",\"nTx\":"
		out.RawString(prefix)
		out.Int(int(in.TxCount))
	}
	{
		const prefix string = ",\"isOrphan\":"
		out.RawString(prefix)
		out.Bool(bool(in.IsOrphan))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v insightBlock) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight7(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v insightBlock) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight7(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *insightBlock) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight7(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *insightBlock) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight7(l, v)
}
func easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgBlockchainUtxo(in *jlexer.Lexer, out *utxo.Tx) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "txid":
			out.TxID = string(in.String())
		case "hash":
			out.Hash = string(in.String())
		case "version":
			out.Version = int(in.Int())
		case "size":
			out.Size = int(in.Int())
		case "vsize":
			out.VSize = int(in.Int())
		case "weight":
			out.Weight = int(in.Int())
		case "locktime":
			out.Locktime = in.JsonNumber()
		case "vin":
			if in.IsNull() {
				in.Skip()
				out.Vins = nil
			} else {
				in.Delim('[')
				if out.Vins == nil {
					if !in.IsDelim(']') {
						out.Vins = make([]utxo.Vin, 0, 1)
					} else {
						out.Vins = []utxo.Vin{}
					}
				} else {
					out.Vins = (out.Vins)[:0]
				}
				for !in.IsDelim(']') {
					var v25 utxo.Vin
					easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgBlockchainUtxo1(in, &v25)
					out.Vins = append(out.Vins, v25)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "vout":
			if in.IsNull() {
				in.Skip()
				out.Vouts = nil
			} else {
				in.Delim('[')
				if out.Vouts == nil {
					if !in.IsDelim(']') {
						out.Vouts = make([]utxo.Vout, 0, 1)
					} else {
						out.Vouts = []utxo.Vout{}
					}
				} else {
					out.Vouts = (out.Vouts)[:0]
				}
				for !in.IsDelim(']') {
					var v26 utxo.Vout
					easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgBlockchainUtxo2(in, &v26)
					out.Vouts = append(out.Vouts, v26)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "hex":
			out.Hex = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgBlockchainUtxo(out *jwriter.Writer, in utxo.Tx) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"txid\":"
		out.RawString(prefix[1:])
		out.String(string(in.TxID))
	}
	{
		const prefix string = ",\"hash\":"
		out.RawString(prefix)
		out.String(string(in.Hash))
	}
	{
		const prefix string = ",\"version\":"
		out.RawString(prefix)
		out.Int(int(in.Version))
	}
	{
		const prefix string = ",\"size\":"
		out.RawString(prefix)
		out.Int(int(in.Size))
	}
	{
		const prefix string = ",\"vsize\":"
		out.RawString(prefix)
		out.Int(int(in.VSize))
	}
	{
		const prefix string = ",\"weight\":"
		out.RawString(prefix)
		out.Int(int(in.Weight))
	}
	{
		const prefix string = ",\"locktime\":"
		out.RawString(prefix)
		out.String(string(in.Locktime))
	}
	{
		const prefix string = ",\"vin\":"
		out.RawString(prefix)
		if in.Vins == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v27, v28 := range in.Vins {
				if v27 > 0 {
					out.RawByte(',')
				}
				easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgBlockchainUtxo1(out, v28)
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"vout\":"
		out.RawString(prefix)
		if in.Vouts == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v29, v30 := range in.Vouts {
				if v29 > 0 {
					out.RawByte(',')
				}
				easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgBlockchainUtxo2(out, v30)
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"hex\":"
		out.RawString(prefix)
		out.String(string(in.Hex))
	}
	out.RawByte('}')
}
func easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgBlockchainUtxo2(in *jlexer.Lexer, out *utxo.Vout) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "value":
			out.Value = in.JsonNumber()
		case "n":
			out.N = int(in.Int())
		case "scriptPubKey":
			easyjson6601e8cdDecode1(in, &out.ScriptPubKey)
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgBlockchainUtxo2(out *jwriter.Writer, in utxo.Vout) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"value\":"
		out.RawString(prefix[1:])
		out.String(string(in.Value))
	}
	{
		const prefix string = ",\"n\":"
		out.RawString(prefix)
		out.Int(int(in.N))
	}
	{
		const prefix string = ",\"scriptPubKey\":"
		out.RawString(prefix)
		easyjson6601e8cdEncode1(out, in.ScriptPubKey)
	}
	out.RawByte('}')
}
func easyjson6601e8cdDecode1(in *jlexer.Lexer, out *struct {
	Asm       string   `json:"asm"`
	Hex       string   `json:"hex"`
	ReqSigs   int      `json:"reqSigs"`
	Type      string   `json:"type"`
	Addresses []string `json:"addresses"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "asm":
			out.Asm = string(in.String())
		case "hex":
			out.Hex = string(in.String())
		case "reqSigs":
			out.ReqSigs = int(in.Int())
		case "type":
			out.Type = string(in.String())
		case "addresses":
			if in.IsNull() {
				in.Skip()
				out.Addresses = nil
			} else {
				in.Delim('[')
				if out.Addresses == nil {
					if !in.IsDelim(']') {
						out.Addresses = make([]string, 0, 4)
					} else {
						out.Addresses = []string{}
					}
				} else {
					out.Addresses = (out.Addresses)[:0]
				}
				for !in.IsDelim(']') {
					var v31 string
					v31 = string(in.String())
					out.Addresses = append(out.Addresses, v31)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson6601e8cdEncode1(out *jwriter.Writer, in struct {
	Asm       string   `json:"asm"`
	Hex       string   `json:"hex"`
	ReqSigs   int      `json:"reqSigs"`
	Type      string   `json:"type"`
	Addresses []string `json:"addresses"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"asm\":"
		out.RawString(prefix[1:])
		out.String(string(in.Asm))
	}
	{
		const prefix string = ",\"hex\":"
		out.RawString(prefix)
		out.String(string(in.Hex))
	}
	{
		const prefix string = ",\"reqSigs\":"
		out.RawString(prefix)
		out.Int(int(in.ReqSigs))
	}
	{
		const prefix string = ",\"type\":"
		out.RawString(prefix)
		out.String(string(in.Type))
	}
	{
		const prefix string = ",\"addresses\":"
		out.RawString(prefix)
		if in.Addresses == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v32, v33 := range in.Addresses {
				if v32 > 0 {
					out.RawByte(',')
				}
				out.String(string(v33))
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}
func easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgBlockchainUtxo1(in *jlexer.Lexer, out *utxo.Vin) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "txid":
			out.TxID = string(in.String())
		case "vout":
			out.Vout = int(in.Int())
		case "scriptSig":
			easyjson6601e8cdDecode2(in, &out.ScriptSig)
		case "txinwitness":
			if in.IsNull() {
				in.Skip()
				out.TxInWitness = nil
			} else {
				in.Delim('[')
				if out.TxInWitness == nil {
					if !in.IsDelim(']') {
						out.TxInWitness = make([]string, 0, 4)
					} else {
						out.TxInWitness = []string{}
					}
				} else {
					out.TxInWitness = (out.TxInWitness)[:0]
				}
				for !in.IsDelim(']') {
					var v34 string
					v34 = string(in.String())
					out.TxInWitness = append(out.TxInWitness, v34)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "sequence":
			out.Sequence = int(in.Int())
		case "coinbase":
			out.Coinbase = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgBlockchainUtxo1(out *jwriter.Writer, in utxo.Vin) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"txid\":"
		out.RawString(prefix[1:])
		out.String(string(in.TxID))
	}
	{
		const prefix string = ",\"vout\":"
		out.RawString(prefix)
		out.Int(int(in.Vout))
	}
	{
		const prefix string = ",\"scriptSig\":"
		out.RawString(prefix)
		easyjson6601e8cdEncode2(out, in.ScriptSig)
	}
	{
		const prefix string = ",\"txinwitness\":"
		out.RawString(prefix)
		if in.TxInWitness == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v35, v36 := range in.TxInWitness {
				if v35 > 0 {
					out.RawByte(',')
				}
				out.String(string(v36))
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"sequence\":"
		out.RawString(prefix)
		out.Int(int(in.Sequence))
	}
	{
		const prefix string = ",\"coinbase\":"
		out.RawString(prefix)
		out.String(string(in.Coinbase))
	}
	out.RawByte('}')
}
func easyjson6601e8cdDecode2(in *jlexer.Lexer, out *struct {
	Asm string `json:"asm"`
	Hex string `json:"hex"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "asm":
			out.Asm = string(in.String())
		case "hex":
			out.Hex = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson6601e8cdEncode2(out *jwriter.Writer, in struct {
	Asm string `json:"asm"`
	Hex string `json:"hex"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"asm\":"
		out.RawString(prefix[1:])
		out.String(string(in.Asm))
	}
	{
		const prefix string = ",\"hex\":"
		out.RawString(prefix)
		out.String(string(in.Hex))
	}
	out.RawByte('}')
}
func easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight8(in *jlexer.Lexer, out *ScriptSig) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "asm":
			if in.IsNull() {
				in.Skip()
				out.Asm = nil
			} else {
				if out.Asm == nil {
					out.Asm = new(string)
				}
				*out.Asm = string(in.String())
			}
		case "hex":
			out.Hex = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight8(out *jwriter.Writer, in ScriptSig) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"asm\":"
		out.RawString(prefix[1:])
		if in.Asm == nil {
			out.RawString("null")
		} else {
			out.String(string(*in.Asm))
		}
	}
	{
		const prefix string = ",\"hex\":"
		out.RawString(prefix)
		out.String(string(in.Hex))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v ScriptSig) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight8(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v ScriptSig) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson6601e8cdEncodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight8(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *ScriptSig) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight8(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *ScriptSig) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson6601e8cdDecodeGithubComshapeshift-legacyCoinqueryV2PkgApiInsight8(l, v)
}
